#' Copy ellipsis arguments from one set of functions to a wrapper function
#'
#' Copies arguments from multiple source functions into a destination function
#' that uses the ellipsis (`...`) to pass arguments to those functions in
#' order to improve documentation.
#'
#' @param ... A list of functions. The last function in the list is used as
#'   a *destination* function, and all previous functions in the list are
#'   considered *source* functions. Arguments from the *source* functions
#'   that do not already appear in the definition of the *destination* function
#'   are copied into the function definition of a wrapper around the
#'   *destination* function.
#'
#' @seealso [inner_function()] and [outer_function()] for examples of the
#' documentation generated by functions using `copy_dots()` like those in
#' the example below. See `merge_dots()` for another approach.
#' @examples
#'
#' # Given these function definitions:
#' inner_function = function(x, y = "old_y_default", z = "z_default") {
#'   cat(x, " ", y, " ", z, "\n")
#' }
#' outer_function = function(y = "new_y_default", ...) {
#'   inner_function(y = y, ...)
#' }
#'
#' # the argument list and documentation of outer_function above will not
#' # include parameters from inner_function, making it harder to
#' # understand. However, copying out these arguments manually is not
#' # a great solution either. `copy_dots()` lets us do this automatically:
#' outer_function = copy_dots(inner_function, function(y = "new_y_default", ...) {
#'   inner_function(y = y, ...)
#' })
#'
#' # The resulting definition of `outer_function` is equivalent to this:
#' outer_function = function(y = "new_y_default", ..., x, z = "z_default") {
#'   (function (y = "new_y_default", ...) {
#'     inner_function(y = y, ...)
#'   })(y = y, ..., x = x, z = z)
#' }
#'
#' @export
copy_dots = function(...) {
  funs = list(...)
  source_funs = funs[-length(funs)]
  dest_fun = funs[[length(funs)]]

  # build up list of arguments from source functions -> dot_args
  dest_args = formals(dest_fun)
  dot_args = list()
  for (source_fun in source_funs) {
    source_args = formals(source_fun)
    dot_args[names(source_args)] = source_args
  }
  # remove any args that are already in the destination function
  dot_args[names(dest_args)] = NULL

  # arguments we will use for the outer wrapper
  outer_args = c(dest_args, dot_args)

  # arguments we will use to call the inner wrapper
  call_arg_names = names(outer_args)
  call_args = lapply(call_arg_names, as.name)
  names(call_args) = call_arg_names
  names(call_args)[call_arg_names == "..."] = list("")

  eval(
    as.call(list(
      as.name("function"),
      as.pairlist(outer_args),
      as.call(c(list(dest_fun), call_args))
    )),
    envir = parent.frame()
  )
}
